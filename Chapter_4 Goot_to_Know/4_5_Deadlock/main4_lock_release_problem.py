# Ошибка при освобождении блокировки.

import asyncio


# корутина, которая приобретает блокировку
async def task(lock):                           # Объявляем асинхронную функцию "task", принимающую в качестве аргумента блокировку
    print('Задача приобретает блокировку...')   # Выводим сообщение о начале приобретения блокировки
    await lock.acquire()                        # Используем метод acquire() для асинхронного приобретения блокировки
    raise Exception('Произошло что-то плохое')  # Генерируем исключение, симулируя ошибку

                                                # освобождаем блокировку (сюда никогда не дойдем)
    print('Задача освобождает блокировку...')   # Сообщение о том, что задача освобождает блокировку
                                                # (но код до этой строки никогда не дойдет из-за исключения выше)
    lock.release()                              # Освобождаем блокировку методом release().
                                                # Так как перед этим есть исключение, то этот код никогда не будет выполнен


async def main():
    lock = asyncio.Lock()                        # Создаем объект блокировки, используя класс Lock из модуля asyncio
    asyncio.create_task(task(lock))              # Создаем новую задачу, используя функцию create_task() модуля asyncio
                                                 # и передаем в нее объект блокировки
    await asyncio.sleep(1)                       # Используем sleep() из модуля asyncio для приостановки выполнения на 1 секунду.
                                                 # Это дает время для другой задачи, чтобы она могла выполниться
    print('Main приобретает блокировку...')      # Сообщаем о том, что основная функция пытается приобрести блокировку
    await lock.acquire()                         # Используем метод acquire() для асинхронного приобретения блокировки
# освобождаем блокировку (сюда никогда не дойдем)
    lock.release()                               # Освобождаем блокировку методом release(). Но этот код не будет выполнен,
                                                 # так как предыдущий вызов acquire() не будет завершен, поскольку задача,
                                                 # которая первоначально приобрела блокировку, не освободила ее из-за ошибки

asyncio.run(main())

# Output:
