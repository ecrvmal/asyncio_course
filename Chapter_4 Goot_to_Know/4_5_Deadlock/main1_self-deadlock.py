# Пример Deadlock, вызванного тем, что корутина ожидает саму себя:
import asyncio

# Корутина, которая дважды получает замок
async def task(lock):
    print('Задача пытается захватить замок...')  # Здесь мы информируем о начале процесса захвата замка

    # Захватываем замок
    async with lock:  # Мы используем контекстный менеджер для безопасного захвата и освобождения замка
        print('Задача снова пытается захватить замок...')  # Информируем о повторном попытке захвата замка

        # Снова захватываем замок
        async with lock:  # Повторный захват замка приведет к взаимной блокировке, так как замок уже занят той же задачей
            # Сюда мы никогда не дойдем
            pass


async def main():
    # Создаем общий замок
    lock = asyncio.Lock()  # Создаем экземпляр замка для использования в корутине
    # Запускаем и ожидаем выполнения корутины
    await task(lock)  # Запускаем корутину с передачей ей замка


asyncio.run(main())  # Запускаем асинхронную функцию main, которая стартует нашу задачу

# Вывод:
# Задача пытается захватить замок...
# Задача снова пытается захватить замок...
# ...
# ...
# # deadlock / бесконечное ожидание корутины / зависание приложения