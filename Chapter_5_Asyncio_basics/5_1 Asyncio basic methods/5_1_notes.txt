Вот короткое описание основных методов, которые предоставляет этот модуль, детальное описание всех аргументов каждого метода с примерами кода будет в следующих степах:

asyncio.run(coro, *, debug=False)  - создаёт цикл событий и запускает указанный coroutine в нём. После завершения выполнения coro автоматически закрывает цикл событий. Этот метод является основным методом для запуска и управления asyncio приложениями.

asyncio.sleep(delay, result=None, *, loop=None) - приостанавливает выполнение текущей корутины на delay секунд.

asyncio.create_task(coro, *, name=None) - оборачивает coro в обёртку задачи, т.е. она будет запланирована для выполнения в цикле событий.

asyncio.wait_for(coro, timeout, *, loop=None) - ожидает завершения coro, и, если выполнение не завершено в течение timeout секунд, вызывается asyncio.TimeoutError.

asyncio.gather(*aws, loop=None, return_exceptions=False) - конкурентно запускает awaitable объекты, переданные в функцию как последовательность *aws, и собирает результаты их работы.

asyncio.wait(fs, *, loop=None, timeout=None, return_when=ALL_COMPLETED) - возвращает кортеж из двух множеств Task/Future в виде (done, pending). Это позволяет вам узнать, какие задачи были выполнены и какие еще ожидают выполнения.

asyncio.ensure_future(obj, *, loop=None) -  Аргумент objвозвращается как есть, если obj является объектом Future, Task или Future-подобным объектом.

Если obj является корутиной, будет создан и возвращен новый объект Task, который оборачивает эту корутину; в этом случае корутина будет запланирована для выполнения с помощью ensure_future().

Если obj является объектом допускающим ожидание, будет возвращен объект Task, который будет ожидать выполнения obj.

Если obj не является ни одним из вышеупомянутых, будет вызвано исключение TypeError.

asyncio.get_event_loop() - метод возвращает текущий цикл событий для текущего контекста.

asyncio.new_event_loop() - метод создает новый цикл событий.

asyncio.set_event_loop(loop) - метод устанавливает цикл событий для текущего контекста.

asyncio.get_running_loop() - метод возвращает текущий запущенный цикл событий в текущем потоке ОС. Вызывает исключение RuntimeError, если нет запущенного цикла событий.

asyncio.shield() - создает объект shield, который может использоваться для защиты кода от воздействия внешних циклов событий или от отмены с помощью  Task.cancel()

asyncio.run_until_complete(future) - метод запускает цикл событий, пока future не выполнится.

asyncio.run_coroutine_threadsafe(coro, loop) - метод является потокобезопасным и предназначен для запуска корутины в указанном цикле событий.

Отличие asyncio.get_event_loop() от asyncio.get_running_loop()
Методы asyncio.get_event_loop() и asyncio.get_running_loop() используются для получения текущего цикла событий, но они работают немного по-разному.

asyncio.get_event_loop() возвращает текущий цикл событий для текущего контекста выполнения. Если текущий цикл событий еще не установлен, метод get_event_loop() будет пытаться установить новый цикл событий и вернуть его. Если цикл событий не может быть получен или установлен, get_event_loop() вызовет ошибку.

С другой стороны, asyncio.get_running_loop() возвращает текущий цикл событий только если он активно выполняется. Если цикл событий не запущен, get_running_loop() вызовет ошибку RuntimeError. Этот метод полезен, когда вы хотите быть уверены, что ваш код выполняется в контексте запущенного цикла событий.

В общем, asyncio.get_running_loop() более строгий, и его использование может помочь избежать некоторых ошибок, связанных с попытками использовать цикл событий, который еще не запущен.